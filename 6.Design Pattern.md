# 6.设计模式

[toc]

> 设计模式相关教程挺多的：
>
> https://geek-docs.com/design-pattern
>
> https://www.runoob.com/design-pattern/design-pattern-tutorial.html

## 23种设计模式

### 抽象工厂模式

提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类

### 工厂方法模式

是简单工厂模式的进一步抽象和推广，是GoF设计模式的一种，由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点

### 建造者模式

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

### 原型模式

是一种创建型设计模式，使你能够复制已有的对象，而无需使代码依赖它们所属的类

### 单例模式

是一种创建型设计模式，它能让你保证一个类只有一个实例，并提供一个访问该实例的全局节点

### 适配器模式

是一种结构型设计模式，它能使接口不兼容的对象能够互相合作

### 桥接模式

是一种结构型设计模式，可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用

### 组合模式

是一种结构型设计模式，你可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用他们

### 装饰者模式

是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为

### 外观模式

是一种结构型设计模式，能为程序库、框架或其他复杂类提供一个简单的接口

### 享元模式

是一种结构型设计模式，它摈弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中载入更多对象

### 代理模式

是一种结构型设计模式，让你能够提供对象的替代品或其占位符，代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理

### 责任链模式

是一种行为型设计模式，允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下一个处理者

### 命令模式

是一种行为设计模式，它可将请求转换为一个包含在请求相关的所有信息的独立对象

### 迭代器模式

是一种行为设计模式，让你能在不暴露集合低层表现形式（列表、栈、树等）的情况下遍历集合中的所有元素

### 中介者模式

是一种行为设计模式，能让你减少对象之间混乱无序的依赖关系，该模式会限制对象之间的直接交互，迫使它们通过一个中介对象进行合作

### 备忘录模式

是一种行为设计模式，允许在不暴露对象实现细节的情况下保存和恢复对象之间的状态

### 观察者模式

是一种行为设计模式，允许你定义一种订阅机制，可在对象事件发生时通知多个“观察”该对象的其他对象

### 状态模式

是一种行为设计模式，让你能在一个对象的内部状态变化时改变其行为，使其看上去就像改变了自身所属类一样

### 策略模式

是一种行为设计模式，能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够互相替换

### 模版方法模式

是一种行为设计模式，它在超类中定义一个算法框架，允许子类在不修改结构的情况下重写算法的特定步骤

### 访问者模式

一种行为型设计模式，能将操作与其所作用的对象隔离开



### 单例模式代码
```java
//1. 饿汉模式
public class InstanceFactory {
    
    // 利用静态变量来记录唯一实例，直接初始化静态变量
    private static final Single instance = new Single();
    
    //构造器私有化
    private InstanceFactory() {}
    
    public static Single getInstance() {
        return this.instance;
    }
}

//2. 懒汉模式，懒加载，双重校验锁
public class InstanceFactory {
    
    //volatile防止重排序
    private volatile static Single instance;
    
    private static final Object object = new Object();
    
    //构造器私有化
    private InstanceFactory(){}
    
    public static Single getInstance() {
        if(instance == null) {
            synchronized(object) {
                if (instance == null) {
                    instance = new Single();
                }
            }
        }
        return instance;
    }
}

//3. 静态内部类，懒加载
public class InstanceFactory {
    private static class InnerClass {
        private static final Single INSTANCE = new Single();
    }
    
    private InstanceFacotry() {}
    
    public static final Single getInstance() {
        return InnerClass.INSTANCE;
    } 
}

//以上方法如果在考虑反射的情况下，依然是能够创建不同的实例的

//4. 枚举实现,最佳单例实现，懒加载
public enum InstanceFactory {
    INSTANCE;
    public InstanceFactory getInstance() {
        return INSTANCE;
    }
}
```



```java
//枚举实现单例demo
public class User {
    //私有化构造函数
    private User(){ }
 
    //定义一个静态枚举类
    static enum SingletonEnum{
        //创建一个枚举对象，该对象天生为单例
        INSTANCE;
        private User user;
        //私有化枚举的构造函数
        private SingletonEnum(){
            user=new User();
        }
        public User getInstnce(){
            return user;
        }
    }
 
    //对外暴露一个获取User对象的静态方法
    public static User getInstance(){
        return SingletonEnum.INSTANCE.getInstnce();
    }
}

public class Test {
    public static void main(String [] args){
        System.out.println(User.getInstance());
        System.out.println(User.getInstance());
        System.out.println(User.getInstance()==User.getInstance());
    }
}
//结果为true
```

